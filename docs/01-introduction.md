# Глава 1: Введение в Go и настройка проекта

В этой главе мы установим Go, познакомимся с основами языка и создадим первую программу. Каждая конструкция будет объяснена простым языком.

---

## 1. Установка Go

**Что такое Go:**  
Go (или Golang) — это язык программирования, созданный в Google. Он простой, быстрый и отлично подходит для создания серверных приложений и ботов.

**Что делаем:**  
Скачиваем и устанавливаем Go на компьютер.

**Шаги:**
1. Перейдите на сайт [https://go.dev/dl/](https://go.dev/dl/)
2. Скачайте установщик для вашей операционной системы
3. Запустите установщик и следуйте инструкциям
4. После установки откройте терминал и проверьте версию:

```bash
go version
```

**Результат:**  
Вы увидите что-то вроде `go version go1.21.0 windows/amd64`. Это значит, что Go установлен правильно.

---

## 2. Создаём папку проекта

**Что делаем:**  
Создаём папку для нашего проекта телеграм-бота и инициализируем Go-модуль.

**Шаги:**
```bash
# Создаём папку проекта
mkdir telegram-bot
cd telegram-bot

# Инициализируем Go-модуль
go mod init telegram-bot
```

**Что такое `go mod init`:**  
Эта команда создаёт файл `go.mod`, который хранит информацию о проекте и его зависимостях (внешних библиотеках). Это как `package.json` в JavaScript или `requirements.txt` в Python.

**Результат:**  
В папке появится файл `go.mod` с содержимым:
```
module telegram-bot

go 1.21
```

---

## 3. Первая программа на Go

**Что делаем:**  
Создаём простейшую программу, чтобы понять основы синтаксиса Go.

**Создайте файл `main.go`:**
```go
package main

import "fmt"

func main() {
    fmt.Println("Привет, Telegram Bot!")
}
```

**Разбор по строкам:**

- `package main` — объявляем, что этот файл принадлежит пакету `main`. В Go каждый файл должен принадлежать какому-то пакету. Пакет `main` — особый, с него начинается выполнение программы.

- `import "fmt"` — подключаем пакет `fmt` (сокращение от "format"). Этот пакет содержит функции для вывода текста на экран.

- `func main()` — объявляем функцию с именем `main`. Ключевое слово `func` означает "функция". Функция `main` — точка входа в программу, она запускается первой.

- `{` и `}` — фигурные скобки обозначают начало и конец тела функции. Всё, что внутри них, выполняется при вызове функции.

- `fmt.Println("Привет, Telegram Bot!")` — вызываем функцию `Println` из пакета `fmt`. Она выводит текст на экран и переходит на новую строку. Текст в кавычках — это строка (string).

**Запускаем программу:**
```bash
go run main.go
```

**Что такое `go run`:**  
Эта команда компилирует (превращает код в программу) и сразу запускает файл. Удобно для разработки.

**Результат:**  
На экране появится: `Привет, Telegram Bot!`

---

## 4. Переменные в Go

**Что такое переменная:**  
Переменная — это именованное место в памяти, где хранится какое-то значение. Как коробка с надписью, в которую можно положить что-то.

**Создаём переменные:**
```go
package main

import "fmt"

func main() {
    // Способ 1: полное объявление
    var botName string = "MyTelegramBot"
    
    // Способ 2: короткое объявление (Go сам определит тип)
    port := 8080
    
    // Способ 3: объявление без значения (будет значение по умолчанию)
    var isActive bool  // по умолчанию false
    
    fmt.Println("Имя бота:", botName)
    fmt.Println("Порт:", port)
    fmt.Println("Активен:", isActive)
}
```

**Разбор:**

- `var botName string = "MyTelegramBot"` — создаём переменную `botName` типа `string` (строка) со значением "MyTelegramBot".
  - `var` — ключевое слово для объявления переменной
  - `botName` — имя переменной (можете назвать как угодно)
  - `string` — тип данных (строка текста)
  - `=` — оператор присваивания
  - `"MyTelegramBot"` — значение переменной

- `:=` — короткий способ создать переменную. Go сам поймёт, что `8080` — это число. Работает только внутри функций.

- `bool` — логический тип, может быть `true` (истина) или `false` (ложь).

- `//` — начало комментария. Всё после `//` до конца строки игнорируется программой.

**Основные типы данных в Go:**

| Тип | Описание | Пример |
|-----|----------|--------|
| `string` | Текст | `"Привет"` |
| `int` | Целое число | `42` |
| `int64` | Большое целое число | `9223372036854775807` |
| `float64` | Дробное число | `3.14` |
| `bool` | Логическое значение | `true`, `false` |

---

## 5. Условные операторы

**Что это:**  
Условные операторы позволяют выполнять разный код в зависимости от условия.

**Пример:**
```go
package main

import "fmt"

func main() {
    userAge := 25
    
    if userAge >= 18 {
        fmt.Println("Пользователь совершеннолетний")
    } else {
        fmt.Println("Пользователь несовершеннолетний")
    }
}
```

**Разбор:**

- `if userAge >= 18` — если `userAge` больше или равно 18
  - `>=` — оператор "больше или равно"
  - Другие операторы сравнения: `==` (равно), `!=` (не равно), `>` (больше), `<` (меньше), `<=` (меньше или равно)

- `else` — иначе (если условие не выполнилось)

**Несколько условий:**
```go
package main

import "fmt"

func main() {
    userStatus := "active"
    
    if userStatus == "active" {
        fmt.Println("Пользователь активен")
    } else if userStatus == "banned" {
        fmt.Println("Пользователь заблокирован")
    } else {
        fmt.Println("Неизвестный статус")
    }
}
```

- `else if` — иначе если (проверяем следующее условие)
- `==` — оператор сравнения "равно" (не путать с `=`, который присваивает значение)

---

## 6. Циклы

**Что это:**  
Циклы позволяют выполнять код несколько раз подряд.

**В Go есть только один цикл — `for`:**
```go
package main

import "fmt"

func main() {
    // Цикл с счётчиком
    for i := 0; i < 5; i++ {
        fmt.Println("Итерация:", i)
    }
}
```

**Разбор:**

- `for i := 0; i < 5; i++` — цикл состоит из трёх частей, разделённых `;`
  - `i := 0` — начальное значение счётчика (создаём переменную `i` равную 0)
  - `i < 5` — условие продолжения (пока `i` меньше 5, цикл работает)
  - `i++` — действие после каждой итерации (`i++` означает `i = i + 1`, то есть увеличиваем на 1)

**Результат:**
```
Итерация: 0
Итерация: 1
Итерация: 2
Итерация: 3
Итерация: 4
```

**Бесконечный цикл:**
```go
for {
    // Этот код будет выполняться вечно
    // Используйте break для выхода
    break  // выход из цикла
}
```

- `break` — команда для выхода из цикла

---

## 7. Функции

**Что это:**  
Функция — это блок кода, который можно вызывать по имени. Помогает не повторять один и тот же код.

**Создаём функцию:**
```go
package main

import "fmt"

// Функция без параметров и без возвращаемого значения
func sayHello() {
    fmt.Println("Привет!")
}

// Функция с параметрами
func greetUser(name string) {
    fmt.Println("Привет,", name)
}

// Функция с возвращаемым значением
func add(a int, b int) int {
    return a + b
}

func main() {
    sayHello()           // Вызываем функцию
    greetUser("Олег")    // Передаём параметр
    
    result := add(5, 3)  // Получаем результат
    fmt.Println("5 + 3 =", result)
}
```

**Разбор:**

- `func sayHello()` — объявляем функцию с именем `sayHello`, без параметров

- `func greetUser(name string)` — функция принимает один параметр `name` типа `string`

- `func add(a int, b int) int` — функция принимает два параметра типа `int` и возвращает `int`
  - `int` после скобок — тип возвращаемого значения
  - `return a + b` — возвращаем результат сложения

**Результат:**
```
Привет!
Привет, Олег
5 + 3 = 8
```

---

## 8. Структуры (struct)

**Что это:**  
Структура — это способ объединить несколько связанных данных в один тип. Похоже на класс в других языках.

**Создаём структуру:**
```go
package main

import "fmt"

// Объявляем структуру User (пользователь)
type User struct {
    ID       int64  // ID пользователя Telegram
    Username string // Имя пользователя
    IsActive bool   // Активен ли пользователь
}

func main() {
    // Создаём экземпляр структуры
    user := User{
        ID:       123456789,
        Username: "john_doe",
        IsActive: true,
    }
    
    // Обращаемся к полям через точку
    fmt.Println("ID:", user.ID)
    fmt.Println("Имя:", user.Username)
    fmt.Println("Активен:", user.IsActive)
    
    // Изменяем поле
    user.IsActive = false
    fmt.Println("Теперь активен:", user.IsActive)
}
```

**Разбор:**

- `type User struct` — создаём новый тип данных с именем `User`
  - `type` — ключевое слово для создания нового типа
  - `struct` — указываем, что это структура

- `ID int64` — поле `ID` типа `int64` (большое целое число, используется для Telegram ID)

- `user := User{...}` — создаём экземпляр (конкретный объект) структуры

- `user.Username` — обращаемся к полю `Username` через точку

**Почему это полезно:**  
Вместо хранения данных в отдельных переменных, мы группируем связанные данные вместе. Это делает код понятнее и безопаснее.

---

## 9. Срезы (slices)

**Что это:**  
Срез — это динамический список элементов одного типа. Похоже на массив, но размер может меняться.

**Работа со срезами:**
```go
package main

import "fmt"

func main() {
    // Создаём пустой срез строк
    var commands []string
    
    // Добавляем элементы с помощью append
    commands = append(commands, "/start")
    commands = append(commands, "/help")
    commands = append(commands, "/settings")
    
    fmt.Println("Все команды:", commands)
    fmt.Println("Количество:", len(commands))
    fmt.Println("Первая команда:", commands[0])
    
    // Перебираем все элементы
    for index, command := range commands {
        fmt.Printf("%d: %s\n", index, command)
    }
}
```

**Разбор:**

- `[]string` — срез строк (квадратные скобки без числа означают срез)

- `append(commands, "...")` — добавляет элемент в конец среза и возвращает новый срез

- `len(commands)` — возвращает количество элементов

- `commands[0]` — получаем элемент по индексу (нумерация с 0)

- `for index, command := range commands` — перебираем срез
  - `range` — ключевое слово для перебора
  - `index` — номер элемента (0, 1, 2...)
  - `command` — сам элемент

- `fmt.Printf` — форматированный вывод
  - `%d` — место для числа
  - `%s` — место для строки
  - `\n` — переход на новую строку

---

## 10. Карты (maps)

**Что это:**  
Карта — это структура данных "ключ-значение". Позволяет быстро находить значение по ключу.

**Работа с картами:**
```go
package main

import "fmt"

func main() {
    // Создаём карту: ключ int64 (ID пользователя), значение string (имя)
    users := make(map[int64]string)
    
    // Добавляем значения
    users[123456789] = "John"
    users[987654321] = "Alice"
    users[555555555] = "Bob"
    
    // Получаем значение по ключу
    fmt.Println("Пользователь 123456789:", users[123456789])
    
    // Проверяем, есть ли ключ
    name, exists := users[999999999]
    if exists {
        fmt.Println("Пользователь найден:", name)
    } else {
        fmt.Println("Пользователь не найден")
    }
    
    // Удаляем элемент
    delete(users, 555555555)
    
    // Перебираем карту
    for userID, userName := range users {
        fmt.Printf("ID: %d, Имя: %s\n", userID, userName)
    }
}
```

**Разбор:**

- `make(map[int64]string)` — создаём карту
  - `make` — встроенная функция для создания карт, срезов и каналов
  - `map[int64]string` — карта с ключами типа `int64` и значениями типа `string`

- `users[123456789] = "John"` — добавляем или изменяем значение

- `name, exists := users[999999999]` — получаем значение и флаг существования
  - `exists` будет `true`, если ключ есть, и `false`, если нет

- `delete(users, 555555555)` — удаляем элемент по ключу

---

## 11. Обработка ошибок

**Важная особенность Go:**  
В Go ошибки не скрываются. Если функция может вернуть ошибку, она возвращает её как второе значение.

**Пример:**
```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // Пытаемся открыть файл
    file, err := os.Open("config.txt")
    
    // Проверяем ошибку
    if err != nil {
        fmt.Println("Ошибка открытия файла:", err)
        return  // Выходим из функции
    }
    
    // Если ошибки нет — используем файл
    defer file.Close()  // defer откладывает выполнение до выхода из функции
    fmt.Println("Файл успешно открыт")
}
```

**Разбор:**

- `file, err := os.Open("config.txt")` — функция `Open` возвращает два значения: файл и ошибку

- `if err != nil` — проверяем, есть ли ошибка
  - `nil` — специальное значение "ничего" для указателей, интерфейсов и ошибок

- `defer file.Close()` — откладывает закрытие файла до выхода из функции. Даже если произойдёт ошибка, файл закроется.

**Почему это важно:**  
В боте мы будем часто получать ошибки от Telegram API. Важно их обрабатывать, чтобы бот не падал.

---

## 12. Указатели

**Что такое указатель:**  
Указатель — это адрес в памяти, где хранится значение. Вместо копирования всей структуры, мы передаём только её адрес.

**Пример:**
```go
package main

import "fmt"

type User struct {
    Name string
    Age  int
}

// Функция, которая изменяет пользователя
func updateUser(user *User) {
    user.Name = "Обновлённое имя"  // Изменяем оригинал
    user.Age = 30
}

func main() {
    user := User{
        Name: "Иван",
        Age:  25,
    }
    
    fmt.Println("До изменения:", user)
    
    updateUser(&user)  // Передаём адрес переменной
    
    fmt.Println("После изменения:", user)
}
```

**Разбор:**

- `*User` — тип "указатель на User"
- `&user` — получить адрес переменной `user`
- `user.Name` — при работе с указателем, Go автоматически разыменовывает его (получает значение)

**Результат:**
```
До изменения: {Иван 25}
После изменения: {Обновлённое имя 30}
```

---

## Что мы узнали

- Как установить Go и создать проект
- Основные типы данных: `string`, `int`, `int64`, `bool`
- Как создавать переменные (полное и короткое объявление)
- Условные операторы `if`, `else`, `else if`
- Цикл `for` и его варианты
- Функции с параметрами и возвращаемыми значениями
- Структуры для группировки данных
- Срезы (динамические списки)
- Карты (ключ-значение)
- Обработку ошибок
- Указатели

---

## Типичные ошибки новичков

**Ошибка 1: Путаете `=` и `==`**
```go
// Неправильно (присваивание вместо сравнения)
if userStatus = "active" {  // ОШИБКА!

// Правильно
if userStatus == "active" {
```

**Ошибка 2: Забываете проверять ошибки**
```go
// Плохо (игнорируем ошибку)
file, _ := os.Open("file.txt")

// Хорошо (проверяем ошибку)
file, err := os.Open("file.txt")
if err != nil {
    return err
}
```

**Ошибка 3: Неправильная работа со срезами**
```go
// Неправильно (выход за границы)
items := []string{"a", "b", "c"}
fmt.Println(items[5])  // ОШИБКА! Выход за границы

// Правильно (проверяем длину)
if len(items) > 5 {
    fmt.Println(items[5])
}
```

---

[Следующая глава: Структура проекта и конфигурация](./02-project-structure.md)

[Вернуться к оглавлению](./README.md)

